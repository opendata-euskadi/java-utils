
The high level architecture of the system is like shown below:

                                _________________________________________________________                               
                                |                                                       |                             _______WAR___________
                                |                                                       |                             |                    |
                                |                .......>[ServicesProxy (RESTClient)] ------<HTTP>-------------------->  [REST end point]  |
                                |                :                                      |                             |       |            |
                                |                :                                      |                             |_______|____________|
                                |                :                                      |                                     |
                                |                :                                      |                                <delegates>
                                |                :                                      |                                     |
[Client] --> {API} --> ((Services Interface] --<conf (r01m.client.properties.xml)>      |                                     |
                                |                :                                      |                                     |    
                                |                :                                      |                                    \|/
                                |                :                                      |                         __________Java Bean____________
                                |                :                                      |                         |                              |
                                |                ........>[ServicesProxy (JavaClient)]------<java/EJB>--> ((Services Interface] [Services Impl]  |
                                |                                                       |                         |                              |
                                |                                                       |                         |______________________________|  
                                |_______________________________________________________|                      
                                
 - The [Client] uses an {API} and only Knows about this API
 
 - The {API} "consumes" services known by their ((Services Interface]
 
 - The ((Services Interface] isolates the {API} from the concrete implementation of the services at the server
   which could be:
   		- A REST end-point
   		- An EJB
   		- A Java Bean
   		- A MOCK impl of the server
   		
 - Using guice & config magic a [Services Proxy] that implements ((Services Interface] is loaded
   This [Services Proxy] implementation knows "how to talk" with the server-side either it's a REST end-point, an EJB or whatever
 
 - If the server-side is implemented using a REST-endpoint or EJB, normally the logic is delegated to THE SAME java bean types
   that implements the ((Services Interface] 
   (the REST web service or the EJB is just a FACADE -another access layer- to the java bean containing services)



-------------------------------
USER GUIDE
-------------------------------

[[[[[[ Client API side ]]]]]]]
[[[[[[ =============== ]]]]]]]

0.- Define the service interfaces
	Service interfaces are just interfaces that extends ServiceInterface type
	
	a) Define a marker interface that extends ServiceInterface. All the service interfaces will extend from this marker interface
	
		public interface MyServiceInterface 
				 extends ServiceInterface {
			// just a marker interface
		}
		
	b) Define a business interface extending the previous marker ServiceInterface
	
		@ExposedServiceInterface
		public interface MyServiceInterfaceForXXX
				 extends MyServiceInterface {
				 
			public void doSomething(final SecurityContext securityContext,...);
		}
		@ExposedServiceInterface
		public interface MyServiceInterfaceForYYY
				 extends MyServiceInterface {
				 
			public void doOtherThing(final SecurityContext securityContext,...);
		}
		
		BEWARE!!
			Service interfaces MUST be annotated with @ExposedServiceInterface because the system will try to
			match all @ExposedServiceInterface-annotated interfaces with a CORE impl or a PROXY to the CORE impe
			(interfaces NOT annotated with @ExposedServiceInterface) will NOT be matched)	
	
1.-	If the CORE-Impl is exposed as a REST service or as an EJB service, for each ServiceInterface, implement a PROXY to the CORE impl 
	create a proxy type
	BEWARE! If the CORE-Impl is directly accessible as a BEAN, there's NO NEED to create a proxy type (skip this step)

	a) Define a marker interface extending ServiceProxyImpl. All proxies will implement this marker interface
	   as well as the ServiceInterface and ProxyFor{Bean|REST|EJB}ImplementedService depending on how the CORE impl is exposed
			
			public interface MyServiceInterfaceCoreImplProxy {
				// just a marker interface
			}
	
	b) Create a proxy type for each ServiceInterface
			- The ServiceInterface ==> Obviously the proxy MUST implement the ServiceInterface
			- The proxy-marker interface
			- The proxy-type marker interface
	
			public class MyServiceProxyForXXX
			  implements MyServiceInterfaceForXXX,			// <-- a proxy for the MyServiceInterfaceForXXX ServiceInterface CORE impl => MUST implement the MyServiceInterfaceForXXX
			  			 MyServiceInterfaceCoreImplProxy,	// <-- it's a proxy 
			  			 ProxyForRESTImplementedService {	// <-- it's a proxy for a REST-exposed service
			 	public void doSomething(final SecurityContext securityContext,...) {
			 		... do whatever should be done to call the bean-exposed services
			 	} 			 
			}
			public class MyServiceProxyForYYY
			  implements MyServiceInterfaceForYYY,			// <-- a proxy for the MyServiceInterfaceForYYY ServiceInterface CORE impl => MUST implement the MyServiceInterfaceForYYY
			  			 MyServiceInterfaceCoreImplProxy,	// <-- it's a proxy 
			  			 ProxyForRESTImplementedService {	// <-- it's a proxy for a REST-exposed service
			 	public void doOtherThing(final SecurityContext securityContext,...) {
			 		... do whatever should be done to call the bean-exposed services
			 	}
			} 

2.- Create an API type exposing the fine-grained ServiceInterface types:
	BEWARE!! The client API is a SINGLETON

		@Singleton
		@Accessors(prefix="_")
		public class MyClientAPI
		     extends ClientAPIImplBase {	// a sub API uses the proxy to access the services layer
		     
			@Inject @SuppressWarnings({ "rawtypes" })
			public MyClientAPI(					       final Provider<SecurityContext> securityContextProvider,
							   @ModelObjectsMarshaller final Marshaller modelObjectsMarshaller,
							   @Named("{clientApiAppCode}") final Map<Class,ServiceInterface> srvcIfaceMappings) {
				super(securityContextProvider,
					  modelObjectsMarshaller,
					  srvcIfaceMappings);	
			}
		}
		API methods are grouped in fine-grained ServiceInterfaces so in order to create an usable API, 
		is a good practice to sub-divide the API into sub-apis (usually one sub api for every ServiceInterface) 
		so the API-usage semantics will be something like:
		
				api.getXXXServices()
						.doSomething();
		
		in order to get this semantics, encapsulate each file-grained ServiceInterface into sub-api delegates 
			public class MyClientSubAPIForXXX
	     		 extends ClientSubAPIBase {
	     		 
	     		// sub-api constructor usually receives the same params as the parent api
	     		public MyClientSubAPIForXXX(final Provider<SecurityContext> securityContextProvider,
							   				final Marshaller modelObjectsMarshaller,
							   				final Map<Class,ServiceInterface> srvcIfaceMappings) {
					super(securityContextProvider,
						  modelObjectsMarshaller,
						  srvcIfaceMappings);	
				}
	     						  		  
	     		public void doSomething(...) {	// note this method DOES NOT have to have the same name as the service interface one and 
	     										// does NOT have the userContext parameter
					this.getServicesProxyAs(MyServiceProxyForXXX.class)	
							.forXXX()
							   .doSomething(this.getUserContext(),	// <-- here the user context is injected 
									   		contentOid);
	     		}			 
	     	}
	     	
		Beware that the API USES the service interface methods BUT DOES NOT IMPLEMENT the service interface; 
		in fact, the API-exposed methods DO NOT have the sercurityContext parameter that the service interface methods DO HAVE.
		This is aliviates the developer of the burden of dealing with the SecurityContext
  
  		Sub-apis are created 'parent' API type and are just final fields of it:
  		
			@Singleton
			@Accessors(prefix="_")
			public class MyClientAPI
			     extends ClientAPIImplBase {	// a sub API uses the proxy to access the services layer
			     
			    @Getter private final MyClientSubAPIForXXX _xxxServices;
			     
				@Inject @SuppressWarnings({ "rawtypes" })
				public MyClientAPI(					       final Provider<SecurityContext> securityContextProvider,
								   @ModelObjectsMarshaller final Marshaller modelObjectsMarshaller,
								   @Named("{clientApiAppCode}") final Map<Class,ServiceInterface> srvcIfaceMappings) {
					super(securityContextProvider,
						  modelObjectsMarshaller,
						  srvcIfaceMappings);	
					// create the sub-apis
					_xxxServices = new MyClientSubAPIForXXX(securityContext,
															marshaller,
															srvcIfaceMappings)
				}
			}

3.- Create a GUIC module for the client bindings:
		@EqualsAndHashCode(callSuper=true) // This is important for guice modules
		public class MyClientBootstrapGuiceModule
		  	 extends ServicesClientAPIBootstrapGuiceModuleBase 	// this is a client guice bindings module
		  implements HasMoreBindings {
		  
			protected MyClientBootstrapGuiceModule(final ServicesClientGuiceBootstrapConfig servicesClientBootstrapCfg) {
				super(servicesClientBootstrapCfg);
			}
			@Override
			public void configureMoreBindings(final Binder binder) {
				// configure any client binding
			}
		}

3.- Create a client bootstrap config:

		@NoArgsConstructor(access=AccessLevel.PRIVATE)
		public abstract class MyClientBootstrapConfigBuilder
				   implements IsBuilder {
			public static ServicesClientBootstrapConfig buildClientBootstrapConfig() {
				return  ServicesClientBootstrapConfigBuilder.forClientApiAppCode({clientApiAppCode})
								  .exposingApi(MyClientAPI.class)
								  .ofServiceInterfacesExtending(MyServiceInterface.class)		// remember step 0??
								  .bootstrappedWith(MyClientBootstrapGuiceModule.class)
								  .build();
			}
		}



					
[[[[[[ Server (core) side ]]]]]]]
[[[[[[ ================== ]]]]]]]	

1.- The services core is normally implemented as BEAN services that encapsulates all the business logic
 	BEWARE!! All services are SINGLETONS!

	a) Define a marker interface that extends CoreService. All the core service impls will extend from this marker interface
	
		public interface MyServiceCoreImpl 
				 extends CoreService {
			// just a marker interface
		}
		
	b.- Create the fine-grained core services implementation
		Each core impl MUST implement;
			- The MyServiceCoreImpl marker interface
			- The corresponding ServiceInterface
		 
			public class MyServiceCoreImplForXXXImpl
			  implements MyServiceInterfaceForXXX,
			  			 MyServiceCoreImpl {	
				public void doSomething(SecurityContext securityContext,...) {
					... the REAL method implementation
				}  
			}
			public class MyServiceInterfaceForYYYImpl
			  implements MyServiceInterfaceForYYY,
			  			 MyServiceCoreImpl {
				public void doOtherthing(SecurityContext securityContext,...) {
					... the REAL method implementation
				}  
			}
			
	The REST services endpoint is only a layer on top of the BEAN services so the REST resources simply "adapts" the BEAN services methods
	to the HTTP protocol semantics, delegating all the logic to the BEAN services 

2.- Create a guice module for the core bindings:

		@EqualsAndHashCode(callSuper=true)											// This is important for guice modules
		public class MyCoreServicesBootstrapGuiceModule
		     extends BeanImplementedPersistenceServicesCoreBootstrapGuiceModuleBase
		  implements ServicesBootstrapGuiceModuleBindsCRUDEventListeners,
		  			 HasMoreBindings {
		  			 
			public MyCoreServicesBootstrapGuiceModule(final ServicesCoreBootstrapConfigWhenBeanExposed coreBootstrapCfg) {
				super(coreBootstrapCfg);
			}
			@Override
			public void configureMoreBindings(final Binder binder) {
				// any core-specific bindings
			}
		}

3.- Create the core bootstrap config

		@NoArgsConstructor(access=AccessLevel.PRIVATE)
		public abstract class MyBeanCoreServicesBootstrapConfigBuilder
				   implements IsBuilder {
				   
			public static ServicesCoreBootstrapConfigWhenBeanExposed buildCoreBootstrapConfig(final XMLPropertiesForApp xmlProps) {
				XMLPropertiesForAppComponent fsXmlProps = xmlProps.forComponent(AppComponent.compose({coreAppCode},
																									 {coreModule});
				return ServicesCoreBootstrapConfigBuilder.forCoreAppAndModule({coreAppCode},{coreModule})
							.beanImplemented()
								.bootstrappedBy(MyCoreServicesBootstrapGuiceModule.class)
								.findServicesExtending(MyServiceCoreImpl.class)			// remember step 0??
								.withSubModulesConfigs(
									// any sub module config built from the properties
								)
								.build();
			}
		}



[[[[[[     Bootstrapping & usage      ]]]]]]]
[[[[[[ ============================== ]]]]]]]

Just USE the bootstrap config builders for the client and core modules

	// [0] - Create the bootstrap cfg
	XMLPropertiesForApp coreXmlProps = XMLPropertiesBuilder.createForApp({coreAppCode})
													   .notUsingCache();

	ServicesBootstrapConfig bootstrapCfg = ServicesBootstrapConfigBuilder
												.forClient(MyClientBootstrapConfigBuilder.buildClientBootstrapConfig())
											    .ofCoreModules(MyBeanCoreServicesBootstrapConfigBuilder.buildCoreBootstrapConfig(coreXmlProps))
											    .notUsingCoreEvents();
	
	// [1] - Create the guice injector 
	// a) create the injector
	Injector guiceInjector = Guice.createInjector(ServicesBootstrapUtil.getBootstrapGuiceModules(bootstrapCfg)
								  									   .withoutCommonBindingModules());
		
	// b) init the services
	// If stand-alone (no app-server is used), init the JPA service or any service that needs to be started
	// like the search engine index
	// 		If the core is available at client classpath, start it
	// 		This is the case where there's no app-server
	// 		(usually the JPA's ServiceHandler is binded at the Guice module extending DBGuiceModuleBase at core side)
	ServicesBootstrapUtil.startServices(GUICE_INJECTOR);
	
	// [3] - Get an api instance
	MyClientAPI clientApi = guiceInjector.getInstance(MyClientAPI.class);	// the client api is a singleton!
	
	// [4] - Use the api
	clientApi.getForXXXServices()
				.doSomething(...)
				
	// [5] - Stop the services
	// Close JPA's Persistence Service, Lucene indexes and everything that has to be closed
	// (see https://github.com/google/guice/wiki/ModulesShouldBeFastAndSideEffectFree)
	ServicesBootstrapUtil.stopServices(guiceInjector);
	
	
	
That's all!!
	
   